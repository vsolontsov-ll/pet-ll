# pet-ll

## Plan
### Low latency logger
#### Type of information required
1. Timestamp (runtime) -- one of the most important attributes of the log record. Different timestamping mechanisms give 
different granularity, accuracy and correlation with machine "wall-clock". One may want to use system clock, 
steady clock, RDTSC or something else. Timestamping mechanism must be configurable at compile time.

2. Threads ID (startup) -- by design logger instance is single-threaded. So no good reason to repeat Thread ID 
again and again.

3. Location in source (compile time) -- __FILE__, __LINE__ and (a bit less) __PRETTY_FUNCTION__ in log macros is a very 
regular practice. Whether you need it in output or not, once it's collected at compile time and doesn't add any 
runtime overhead, worth to have it.

4. Serialization format (compile time) -- this is a binary logger. It doesn't format records at runtime. How to dump 
the data into buffers must be known at compile time.

5. Parising format (compile time / ? startup) -- this format tells how to parse the data from binary buffers. 

6. Format string (compile time / ? startup) -- in majority of cases you at compile time know how you would want to 
format your text in the log record. 

7. Dynamic data (runtime) -- the data your program actually aquired at run time. By it's nature it's runtime and that's
the main source of complexity (all the compile time and startup data can be encoded by a single integer).

##### Supported data types
* Built-in (int, const char*, ...) -- first cut plan
* String literals -- next iteration
* Complex objects. As an idea it can provide a format string, decoding format and serialization function at compile
time. 

#### Why using .init_array
It's not easy writing low latency code. 
Permanently checking assembly generated by a compiler is annoying (but thanks to Met Godbolt, he made it easier).
Sometimes it requires to add compiler-specific attributes or platform-specific calls/instructions.

So portability of this code is limited by definition. Based on requirements, partability/standard-compliece 
could be not a good reason for poor performance. 
In other words, squeezing a few CPU cycles could be considered as a good enough reason for using a trick which in 
all other scenarios must be rejected as a "dirty hack".   

Initarray is a section in ELF containing a flat array of pointers to functions. The functions to be called at startup.
C++ compilers usually uses this sections for initializing global and name-space-scoped static objects.

Different platforms may have different order of initialization of even ignore this section. So this approach **is not 
portable**.


### Tagged integers
Time to time it's nice to destinguish integer arguments by type. 
E.g. it's done in std::chrono for date/time components.

Also it could be convenient to add basic operations 
* Arithmetics
  * Addiotion with integers
  * Addiotion with the same type
  * Multiplication with integers
  * Multiplication with the same type
* Implicit conversion to integer 
* Comparisons 

The majority of operations listed above might be needed or not and even can be harmful.
So it would be nice to make all the operations (probably apart from comparicon for equality) optional.

